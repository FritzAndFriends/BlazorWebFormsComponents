@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using System.Linq.Expressions

@inherits ComponentBase

@if (!_isValid)
{
    <span>@Text</span>
}

@code
{
    [CascadingParameter] EditContext CurrentEditContext { get; set; }

    [Parameter] public ForwardRef<InputText> ControlToValidate { get; set; }
    [Parameter] public string Text { get; set; }
    [Parameter] public string ErrorMessage { get; set; }

    private bool _isValid = true;

    protected override void OnInitialized()
    {
        // ValidationMessageStore is sealed. I have a feeling I will need to implement my own.
        var messages = new ValidationMessageStore(CurrentEditContext);

        CurrentEditContext.OnValidationRequested += (sender, eventArgs) => EventHandler((EditContext)sender, messages);

        base.OnInitialized();
    }

    public void EventHandler(EditContext editContext, ValidationMessageStore messages)
    {
        string name;
        if (ControlToValidate.Current.ValueExpression.Body is MemberExpression memberExpression)
        {
            name = memberExpression.Member.Name;
        }
        else
        {
            throw new Exception();
        }

        var fieldIdentifier = CurrentEditContext.Field(name);
        
        // TODO : The field could have multiple validator
        // I Have to find a way to clear message only for this validator.
        messages.Clear(fieldIdentifier);

        if (string.IsNullOrEmpty(ControlToValidate.Current.Value))
        {
            _isValid = false;
            messages.Add(fieldIdentifier, Text + "," + ErrorMessage);
        }
        else
        {
            _isValid = true;
        }

        editContext.NotifyValidationStateChanged();
    }
}